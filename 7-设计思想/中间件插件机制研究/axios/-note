

原demo: axios的使用
    const _axios = axios.create({
        baseURL: 'https://some-domain.com/api/',
        timeout: 1000,
        headers: {'X-Custom-Header': 'foobar'}
    });

    // 设置拦截器（相当于是中间件，开了个口)
    // 拦截器可以干嘛？请求拦截器 可以在参数上 header塞入token， 
                     返回拦截器 对所有的请求handle 若状态码为xx 则是token失效，此时可以在拦截器层面做登录退出
                     或者是 在拦截器前后配合使用 在请求发起 与 请求结束期间，显示loading
    // 拦截器的时机
            1、可以在请求前在参数 or 请求后处理结果值
            2、use函数接受两个回调函数，
    // 请求拦截器
    _axios.interceptors.request.use(function (config) {
        // 在发起请求前做点什么
        return config;
    }, function (error) {
        // 对请求错误做点什么
        return Promise.reject(error);
    });

    // 响应拦截器
    _axios.interceptors.response.use(function (response) {
        // 响应是2xx的状态码 都在这里触发
        // 加工一下响应数据
        return response;
    }, function (error) {
        // 只要不是2xx的状态码 都在这里触发
        // 对响应错误做点什么
        return Promise.reject(error);
    });


    // 运行 调用各种实例方法如 .get, .post等 都会经过拦截器的处理
    _axios.get("").then(res => res)
    _axios({
        method: 'post',
        url: '/user/12345',
        data: {
            firstName: 'Fred',
            lastName: 'Flintstone'
        }
    }).then(res => res);
实际的简化实践：
    axios.run(config).then(res => res);

    实现原理：
        注册的时候就是 
            request.use(resolvefunc, rejectfunc) 
            response.use(resolvefunc, rejectfunc)
        那么和promise的实现一直，在内部维护了resolvecbarr, rejectcbarr 在适当的时候依次调用
        // 请求拦截器1
        // axios.useRequestInterceptor(resolved1, rejected1);
        // // 请求拦截器2
        // axios.useRequestInterceptor(resolved2, rejected2);
        // // 响应拦截器1
        // axios.useResponseInterceptor(resolved1, rejected1);
        // // 响应拦截器
        // axios.useResponseInterceptor(resolved2, rejected2);
        // 读取 注册 生成chain链
        // [
        //     请求拦截器2，// ↓config
        //     请求拦截器1，// ↓config
        //     axios请求核心方法, // ↓response
        //     响应拦截器1, // ↓response
        //     响应拦截器// ↓response
        // ]
        // 为啥请求拦截2 要在 请求拦截1前面？


所以本质是
    接受存纳 回调，（请求前的回调，请求后的回调），将这些回调串行执行，
    异步的串行处理，不能单独的暴力执行，所以借用了 promise.then 以promise链的方式

    和lazyman的实现差不多其实

作为插件角度，
    axios实现的是  输入params —— (网络请求) —— 输出response
    插件此时是以拦截器身份出现， 请求前，     请求后拿到结果值时 
        所以插件是将数据无条件抛给了插件，且中间的处理过程data是传递性的，
                ↓
        经过插件后 用户只需关心最后的加工后的数据值final_data

        在此基础上，会传递请求的库内部处理请求时的状态，发出请求成功后 失败后 对应响应插件的 两个回调
    所以从这个需求角度，
        插件的角度：库内部 调用时机+输入参数
                   插件处理，两个回调


总结 
    vuex 和 axios的实现区别
        axios： request.use() response.use() 注册回调
                插件内部 将回调集函数 与 原core函数 协调好位置后 用promise链的方式组织，
                开放数据方面：全给
                数据变化方面（调用时机）：
        vuex：  plugin vuex.suscribe 
                给每个实例触动一下，mulation里get、post方法等 
                或者是 针对mulation里的 每一次触发 就调用
                