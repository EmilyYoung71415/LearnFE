<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title></title>
	<link rel="stylesheet" href="">
</head>
<body>
	
</body>
<script type="text/javascript">
	//1.引言
　　var Chinese = {
　　　　nation:'中国1'
　　};
	/*var Doctor ={
　　　　career:'医生'
　　}*/
	//怎样让医生去继承中国人？成为中国医生？
	//1.object()方法 使用prototype链
	/*function object(o) {
　　　　function F() {}
　　　　F.prototype = o;//子对象的prototype属性，指向父对象
　　　　return new F();
　　}
	var Doctor = object(Chinese);//父对象的基础上生成了对象
	Doctor.career = "医生";//加上子对象本身的属性
	console.log(Doctor.nation);*/

	//2.浅拷贝  把父对象的属性，全部拷贝给子对象，也能实现继承。
	/*function extendCopy(p){
		var c = {};
		for(var i in p){
			c[i] = p[i];
		}
		c.uber = p;
		//为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。
		return c;
	}
	var Doctor = extendCopy(Chinese);
	Doctor.career = "医生";
	//console.log(Doctor.nation);
	//存在隐患：
	//如果父对象的属性等于数组或另一个对象，实际上子对象获得的只是一个内存地址不是真正拷贝，存在父对象被篡改的可能。
	Chinese.birthPlaces = ['北京','上海','香港'];
	var Doctor = extendCopy(Chinese);
	Doctor.birthPlaces.push("绵阳");
	console.log(Doctor.birthPlaces);//北上香绵阳
	console.log(Chinese.birthPlaces);//北上香绵阳*/


	/*3.深拷贝  递归调用"浅拷贝"，真正意义上实现数组和对象的拷贝  */

	　function deepCopy(p, c) {
　　　　var c = c || {};
　　　　for (var i in p) {
　　　　　　if (typeof p[i] === 'object') {
　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};
　　　　　　　　deepCopy(p[i], c[i]);
　　　　　　} else {
　　　　　　　　　c[i] = p[i];
　　　　　　}
　　　　}
　　　　return c;
　　}
	　
	　Chinese.birthPlaces = ['北京','上海','香港'];
	  var Doctor = deepCopy(Chinese);
　　  Doctor.birthPlaces.push('厦门');

	  console.log(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
	  console.log(Chinese.birthPlaces); //北京, 上海, 香港


</script>
</html>