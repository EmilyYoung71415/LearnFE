<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title></title>
	<link rel="stylesheet" href="">
</head>
<body>
	
</body>
<script type="text/javascript">
	/*一. 生成实例对象的原始模式*/
	var cat = {//原型对象
		name:"",
		color:""
	}
	var cat1={};//生成一个空对象
	cat1.name = "张三";//按照原型对象的属性赋值
	cat1.age = "18";
	console.log(cat1);
	/* 总结：
		最简单的封装，把两个属性值放在一个对象里面。
		但是这样写有两个缺点:
		1.如果多生成几个实例，写起来就特别麻烦
		2.实例与原型之间，看不出有什么联系
	*/
	/*二. 原始模式改进*/
	/*function cat(name,color){
		return{
			name:name,
			color:color
		}
	}*/
	//var cat1 = cat("张三","yellow");
	//var cat2 = cat("张三的弟弟张四","red");
	//console.log(cat("张三","yellow"));
	/* 总结：
		cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例
	*/

	/*三. 构造函数模式*/
	/*function Cat(name,color){
		this.name = name;
		this.color = color;
	}
	var cat1 = new Cat("张三","yellow");
	var cat2 = new Cat("张三的弟弟张四","red");
	console.log(cat2.name);
	/*
		为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。
		所谓"构造函数"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。
		这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
	*/

	//console.log(cat1.constructor == Cat);//cat1.constructor属性指向它们的构造函数
	//Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
	//console.log( cat1 instanceof  Cat);//true
	//构造函数的缺点：浪费内存


	/*四. Prototype模式*/
	//解决让某公用属性或方法在内存中只生成一次，然后所有实例都指向那个内存地址，不占用多的内存提高效率
	//Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。
	//即可把一些不变的属性和方法 直接定义在prototype对象上
	function Cat(name,color){
		this.name = name;
		this.color = color;
	}
	Cat.prototype.type = "猫科动物";
	Cat.prototype.eat = function() {alert(111);}

	var cat1 = new Cat ("测试","颜色");
	//console.log(cat1.type);
	//cat1.eat();
	//type 和eat方法都是同一个内存地址，指向prototype对象，因此提高效率

	/*五. Prototype模式的辅助方法*/
	//isPrototypeOf()===>这个方法用来判断，某个proptotype对象和某个实例之间的关系
	//hasOwnProperty()
	//每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。
	//in运算符
	//某个实例是否含有某个属性，不管是不是本地属性||用来遍历



	/*
		大总结：
		本节内容：如何"封装"数据和方法，以及如何从原型对象生成实例。
	*/
</script>



</html>